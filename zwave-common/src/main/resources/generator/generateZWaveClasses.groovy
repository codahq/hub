/*
 * Copyright (c) 2021 by the respective copyright holders.
 * All rights reserved.
 * <p>
 * This file is part of Parrot Home Automation Hub.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
@Grab(group = 'org.yaml', module = 'snakeyaml', version = '1.27')
import org.yaml.snakeyaml.Yaml

String fileToParse = "zwaveClasses.yaml"
String basePackage = "com.parrotha.zwave"
String baseDirectory = "../../java/"
String licenseFile = "license.txt"

String licenseText = new File(licenseFile).text

//generate common Command class
generateCommandJavaClass(basePackage, baseDirectory + basePackage.replace(".", "/"), licenseText)

// load yaml file
List zwaveClasses = null;
try {
    Yaml yaml = new Yaml();
    File zwaveClassesSource = new File(fileToParse);
    zwaveClasses = yaml.load(new FileInputStream(zwaveClassesSource));
} catch (IOException e) {
    e.printStackTrace();
}

// create java files in commands package
generateCommandsJava(zwaveClasses, basePackage, baseDirectory, licenseText)

// generate java files in commandclasses package
generateCommandClassesJava(zwaveClasses, basePackage, baseDirectory, licenseText)

// generate Zwave java class
generateZwaveJavaClass(zwaveClasses, basePackage, baseDirectory + basePackage.replace(".", "/"), licenseText)

// generate Zwave command enum class
generateZWaveCommandEnumJavaClass(zwaveClasses, basePackage, baseDirectory + basePackage.replace(".", "/"), licenseText)

/*
 *  Methods to generate java files
 */

// generates the java classes in commandclasses package
void generateCommandClassesJava(List zwaveClasses, String basePackage, String baseDirectory, String licenseText) {
    if (zwaveClasses == null) return;

    String baseCodeDirectory = baseDirectory + basePackage.replace(".", "/") + "/commandclasses/"
    new File(baseCodeDirectory).mkdirs()
    zwaveClasses.each { Map commandClassDetails ->

        File f = new File("${baseCodeDirectory}${commandClassDetails.commandClass}V${commandClassDetails.version}.java")
        println "Generating ${f.getPath()}"
        if (f.exists()) f.delete()
        f << licenseText
        f << "package com.parrotha.zwave.commandclasses;\n"
        f << "\n"
        f << "import org.apache.commons.beanutils.BeanUtils;\n"
        f << "\n"
        f << "import java.lang.reflect.InvocationTargetException;\n"
        f << "import java.util.Map;\n"
        f << "\n"
        f << "/**\n"
        f << " * Note: This code is autogenerated, changes will be overwritten.\n"
        f << " */\n"
        f << "public class ${commandClassDetails.commandClass}V${commandClassDetails.version} {\n"
        commandClassDetails.commands.each { String commandName, Map commandDetails ->
            String fqcn = "${basePackage}.commands.${commandClassDetails.commandClass.toLowerCase()}v${commandClassDetails.version}.${commandName}"
            f << "    public ${fqcn} ${commandName.uncapitalize()}() {\n"
            f << "        return new ${fqcn}();\n"
            f << "    }\n\n"
            f << "    public ${fqcn} ${commandName.uncapitalize()}(Map values) throws InvocationTargetException, IllegalAccessException {\n"
            f << "        ${fqcn} cmd = new ${fqcn}();\n"
            f << "        BeanUtils.populate(cmd, values);\n"
            f << "        return cmd;\n"
            f << "    }\n\n"
        }
        f << "}\n"
    }
}

boolean firstVariableIsListType(List payload) {
    if(payload != null && payload.size() > 0 && (((String) payload.get(0).type).startsWith("List") || ((String) payload.get(0).type).startsWith("Integer"))) {
        return true;
    }
    return false
}

boolean containsSingleVariables(List payload) {
    boolean retVal = false
    payload.each { payloadItem ->
        if (((String) payloadItem.type).equalsIgnoreCase("short") ||
                ((String) payloadItem.type).equalsIgnoreCase("boolean")) {
            retVal = true
        }
    }
    return retVal
}

boolean containsIntegerVariables(List payload) {
    boolean retVal = false
    payload.each { payloadItem ->
        if (((String) payloadItem.type).equalsIgnoreCase("Integer")) {
            retVal = true
        }
    }
    return retVal
}


// generates the java classes in commands package
void generateCommandsJava(List zwaveClasses, String basePackage, String baseDirectory, String licenseText) {
    if (zwaveClasses == null) return;
    String baseCodeDirectory = baseDirectory + basePackage.replace(".", "/") + "/commands/"

    new File(baseCodeDirectory).mkdirs()

    zwaveClasses.each { Map commandClassDetails ->
        // create directory
        String ccDir = "${baseCodeDirectory}${commandClassDetails.commandClass.toLowerCase()}v${commandClassDetails.version}"
        new File(ccDir).mkdir()
        commandClassDetails.commands.each { String commandName, Map commandDetails ->
            // do not generate the file if the manual flag is set to true
            if (commandDetails.manual == null || commandDetails.manual != true) {
                println "Generating ${basePackage}.commands.${commandClassDetails.commandClass.toLowerCase()}v${commandClassDetails.version}.${commandName}"
                File f = new File("${ccDir}/${commandName}.java")
                if (f.exists()) f.delete()
                f << licenseText
                f << "package ${basePackage}.commands.${commandClassDetails.commandClass.toLowerCase()}v${commandClassDetails.version};\n"
                if (commandDetails.extends == null) {
                    f << "\n"
                    f << "import com.parrotha.zwave.Command;\n"
                }
                if (commandDetails.overridePayload == null || commandDetails.overridePayload == true) {
                    f << "\n"
                    if (containsIntegerVariables((List) commandDetails.payload)) {
                        f << "import com.parrotha.internal.utils.HexUtils;\n"
                    }
                    if (commandDetails.payload?.size() > 0 && containsSingleVariables((List) commandDetails.payload) && !firstVariableIsListType((List) commandDetails.payload)) {
                        f << "import java.util.List;\n"
                        f << "import java.util.stream.Collectors;\n"
                        f << "import java.util.stream.Stream;\n"
                    } else {
                        f << "import java.util.ArrayList;\n"
                        f << "import java.util.List;\n"
                    }
                }
                if(commandDetails.additionalImports != null) {
                    f << commandDetails.additionalImports
                }

                f << "\n"
                f << "/**\n"
                f << " * Note: This code is autogenerated, changes will be overwritten.\n"
                f << " */\n"
                if (commandDetails.extends == null) {
                    f << "public class ${commandName} extends Command {\n"
                } else {
                    f << "public class ${commandName} extends ${basePackage}.commands.${commandClassDetails.commandClass.toLowerCase()}v${commandDetails.extends}.${commandName} {\n"
                }
                if (commandDetails.constants?.size() > 0) {
                    commandDetails.constants.each { Map constantItem ->
                        f << "    public static final ${constantItem.type} ${constantItem.name} = ${constantItem.value};\n"
                    }
                    f << "\n"
                }
                if (commandDetails.value != null) {
                    f << "    public String getCMD() {\n"
                    f << "        return \"${String.format("%02X", commandClassDetails.value)}${String.format("%02X", commandDetails.value)}\";\n"
                    f << "    }\n"
                    f << "\n"
                }
                if (commandDetails.overridePayload == null || commandDetails.overridePayload == true) {
                    if (commandDetails.payload?.size() > 0) {
                        commandDetails.payload.each { Map payloadItem ->
                            f << createInstanceVariable(payloadItem.name, payloadItem.type, payloadItem.defaultValue)
                        }
                        f << "\n"
                        commandDetails.payload.each { Map payloadItem ->
                            f << createInstanceVariableGetterAndSetter(payloadItem.name, payloadItem.type)
                        }
                    }

                    f << createPayload(commandDetails.payload, commandClassDetails['value'], commandDetails['value'])
                    f << "\n"
                    f << createToString(commandClassDetails.commandClass, commandName, commandDetails.payload)
                }

                if(commandDetails.additionalMethods != null) {
                    if(commandDetails.additionalMethods instanceof String) {
                        f << commandDetails.additionalMethods
                    } else if (commandDetails.additionalMethods instanceof List) {
                        commandDetails.additionalMethods.each {
                            f << it;
                        }
                    }
                }
                f << "}\n"
            }
        }
    }
}

String createPayload(List payload, Integer commandClass, Integer command) {
    StringBuilder setPayloadBuilder = new StringBuilder("    public void setPayload(List<Short> payload) {\n")
    if (payload?.size() > 0) {
        setPayloadBuilder.append("        if (payload == null) return;\n")
    }
    StringBuilder getPayloadBuilder = new StringBuilder("    public List<Short> getPayload() {\n")
    if (payload?.size() > 0) {
        boolean dataVariablesRequired = false
        boolean listVariablesPresent = false
        boolean firstVariableIsList = firstVariableIsListType(payload)
        boolean singleVariablesPresent = containsSingleVariables(payload)

        payload.each { payloadItem ->
            if (((String) payloadItem.data).contains(":")) {
                dataVariablesRequired = true
            }
            if (((String) payloadItem.type).startsWith("List") || ((String) payloadItem.type).startsWith("Integer")) {
                listVariablesPresent = true
            }
        }

        if (dataVariablesRequired) {
            getPayloadBuilder << buildGetPayloadDataVariables(payload)
        }

        String lastMultiBitData = "-1"
        boolean openSetPayloadIf = false
        boolean closedGetPayloadStream = false;

        if (!listVariablesPresent) {
            getPayloadBuilder.append("        return Stream.of(")
        } else if ((singleVariablesPresent || dataVariablesRequired) && !firstVariableIsList) {
            getPayloadBuilder.append("        List<Short> retList = Stream.of(")
        } else {
            getPayloadBuilder.append("        List<Short> retList = new ArrayList<>();\n")
            closedGetPayloadStream = true;
        }


        for (int index = 0; index < payload.size(); index++) {
            Map payloadItem = payload.get(index)
            if (((String) payloadItem.data).contains(":")) {
                String dataNum = ((String) payloadItem.data).split(":")[0]
                String payloadItemData = dataNum
                if (dataNum.startsWith("RAW[")) {
                    payloadItemData = dataNum.substring("RAW[".length(), dataNum.length() - 1)
                }

                if (dataNum != lastMultiBitData) {
                    if (openSetPayloadIf) {
                        setPayloadBuilder.append("        }\n")
                    }
                    lastMultiBitData = dataNum

                    openSetPayloadIf = true

                    String dataVarName = payloadItem.dataVarName ?: "data${dataNum}"
                    if (closedGetPayloadStream) {
                        getPayloadBuilder.append("        retList.add(${dataVarName});\n");
                    } else {
                        if (index > 0) {
                            getPayloadBuilder.append(", ")
                        }
                        getPayloadBuilder.append(dataVarName)
                    }

                    setPayloadBuilder.append("        if (payload.size() > ${payloadItemData}) {\n")
                }
                setPayloadBuilder.append(buildSetPayloadSubBitField(payloadItem, payloadItemData))
            } else {
                if (openSetPayloadIf) {
                    setPayloadBuilder.append("        }\n")
                    openSetPayloadIf = false
                }

                if (payloadItem.name == "RESERVED" && payloadItem.type == "Short" && payloadItem.defaultValue != null) {
                    if (closedGetPayloadStream) {
                        getPayloadBuilder.append("        retList.add((short) ${payloadItem.defaultValue});\n");
                    } else {
                        if (index > 0) {
                            getPayloadBuilder.append(", ")
                        }
                        getPayloadBuilder.append("(short) ${payloadItem.defaultValue}")
                    }
                } else if (payloadItem.type == "Short") {
                    buildShortPayload(setPayloadBuilder, getPayloadBuilder, payloadItem, index, closedGetPayloadStream)
                } else if (payloadItem.type == "List<Short>") {
                    // we have a value that spans multiple bytes
                    String strStartDataNum = ((String) payloadItem.data).split("~")[0]
                    String strEndDataNum = ((String) payloadItem.data).split("~")[1]

                    if (strStartDataNum.startsWith("RAW[")) {
                        strStartDataNum = strStartDataNum.substring("RAW[".length(), strStartDataNum.length() - 1)
                    }
                    if (strEndDataNum.startsWith("RAW[")) {
                        strEndDataNum = strEndDataNum.substring("RAW[".length(), strEndDataNum.length() - 1)
                    }

                    if(payloadItem.minPayloadSize != null) {
                        setPayloadBuilder.append("        if (payload.size() > ${payloadItem.minPayloadSize}) {\n")
                    } else {
                        if(strEndDataNum.replace(" ", "") == "(payload.size()-1)") {
                            setPayloadBuilder.append("        if (payload.size() > ${strStartDataNum}) {\n")
                        } else {
                            setPayloadBuilder.append("        if (payload.size() > ${strEndDataNum}) {\n")
                        }
                    }

                    setPayloadBuilder.append("            ${payloadItem.name} = payload.subList(${strStartDataNum}, ${strEndDataNum});\n")
                    setPayloadBuilder.append("        }\n")

                    if (!closedGetPayloadStream && (singleVariablesPresent || dataVariablesRequired)) {
                        getPayloadBuilder.append(").collect(Collectors.toList());\n")
                        closedGetPayloadStream = true;
                    }
                    getPayloadBuilder.append("        retList.addAll(${payloadItem.name});\n")
                } else if (payloadItem.type == "Integer") {
                    // we have a value that spans multiple bytes
                    String strStartDataNum = ((String) payloadItem.data).split("~")[0]
                    String strEndDataNum = ((String) payloadItem.data).split("~")[1]

                    if (strStartDataNum.startsWith("RAW[")) {
                        strStartDataNum = strStartDataNum.substring("RAW[".length(), strStartDataNum.length() - 1)
                    }
                    if (strEndDataNum.startsWith("RAW[")) {
                        strEndDataNum = strEndDataNum.substring("RAW[".length(), strEndDataNum.length() - 1)
                    }

                    int minBytes
                    if(payloadItem.minBytes != null) {
                        minBytes = payloadItem.minBytes
                    } else {
                        minBytes = Integer.valueOf(strEndDataNum) - Integer.valueOf(strStartDataNum) + 1
                    }

                    String minPayloadSize = strEndDataNum
                    if(payloadItem.minPayloadSize != null) {
                        minPayloadSize = payloadItem.minPayloadSize
                    }

                    setPayloadBuilder.append("        if (payload.size() > ${minPayloadSize}) {\n")
                    setPayloadBuilder.append("            ${payloadItem.name} = HexUtils.shortListToInteger(payload.subList(${strStartDataNum}, ${strEndDataNum}));\n")
                    setPayloadBuilder.append("        }\n")

                    if (closedGetPayloadStream) {
                        getPayloadBuilder.append("        retList.addAll(HexUtils.integerToShortList(${payloadItem.name}, ${minBytes}));\n");
                    } else {
                        if (!closedGetPayloadStream && (singleVariablesPresent || dataVariablesRequired)) {
                            getPayloadBuilder.append(").collect(Collectors.toList());\n")
                            closedGetPayloadStream = true;
                        }
                        getPayloadBuilder.append("        retList.addAll(HexUtils.integerToShortList(${payloadItem.name}, ${minBytes}));\n");
                    }
                } else {
                    if (closedGetPayloadStream) {
                        getPayloadBuilder.append("        retList.add((short) 0 /*TODO: FixMe*/);\n");
                    } else {
                        if (index > 0) {
                            getPayloadBuilder.append(", ")
                        }
                        getPayloadBuilder.append("(short) 0 /*TODO: FixMe*/")
                    }
                }
            }
        }
        if (openSetPayloadIf) {
            setPayloadBuilder.append("        }\n")
            openSetPayloadIf = false
        }

        if (listVariablesPresent) {
            getPayloadBuilder.append("        return retList;\n")
        } else {
            getPayloadBuilder.append(").collect(Collectors.toList());\n")
        }


    } else {
        getPayloadBuilder.append("        return new ArrayList<>();\n")
    }
    getPayloadBuilder.append("    }\n")
    setPayloadBuilder.append("    }\n")

    return getPayloadBuilder.append("\n").append(setPayloadBuilder.toString()).toString()
}

void buildShortPayload(StringBuilder setPayloadBuilder, StringBuilder getPayloadBuilder, Map payloadItem, int index, boolean closedGetPayloadStream) {
    if (closedGetPayloadStream) {
        getPayloadBuilder.append("        retList.add(${payloadItem.name});\n");
    } else {
        if (index > 0) {
            getPayloadBuilder.append(", ")
        }
        getPayloadBuilder.append("${payloadItem.name}")
    }

    if (((String) payloadItem.data).startsWith("RAW[")) {
        String payloadItemData = ((String) payloadItem.data).substring("RAW[".length(), ((String) payloadItem.data).length() - 1)
        setPayloadBuilder.append("        if (payload.size() > ${payloadItemData}) {\n")
        setPayloadBuilder.append("            ${payloadItem.name} = payload.get(${payloadItemData});\n")
    } else {
        setPayloadBuilder.append("        if (payload.size() > ${payloadItem.data}) {\n")
        setPayloadBuilder.append("            ${payloadItem.name} = payload.get(${payloadItem.data});\n")
    }

    setPayloadBuilder.append("        }\n")
}

String buildSetPayloadSubBitField(Map payloadItem, String dataNum) {
    String bits = ((String) payloadItem.data).split(":")[1]
    if (bits.contains("~")) {
        int startBit = Integer.parseInt(bits.split("~")[0])
        int stopBit = Integer.parseInt(bits.split("~")[1])
        if (startBit > 0) {
            // shift value
            if (payloadItem.type == "Short") {
                return "            ${payloadItem.name} = (short) ((payload.get(${dataNum}) & ${getBitwiseAndByte(stopBit - startBit + 1, startBit)}) >> ${startBit});\n"
            } else {

            }
        } else {
            if (payloadItem.type == "Short") {
                return "            ${payloadItem.name} = (short) (payload.get(${dataNum}) & ${getBitwiseAndByte(stopBit - startBit + 1)});\n"
            } else {

            }
        }
    } else {
        // we have a single bit field
        int bit = Integer.parseInt(bits)
        if (payloadItem.type == "Boolean") {
            if (bit > 0) {
                return "            ${payloadItem.name} = ((payload.get(${dataNum}) >> ${bit}) & 1) == 1;\n"
            } else {
                return "            ${payloadItem.name} = ((payload.get(${dataNum})) & 1) == 1;\n"
            }
        }
    }
}

String buildGetPayloadDataVariables(List<Map> payload) {
    StringBuilder dataVariablesStringBuilder = new StringBuilder();

    for (int index = 0; index < payload.size(); index++) {
        Map payloadItem = payload.get(index)
        if (((String) payloadItem.data).contains(":")) {
            String dataNum = ((String) payloadItem.data).split(":")[0]
            // get rest of data
            List dataPayloadList = []
            for (int j = index; j < payload.size(); j++) {
                if (((String) payload.get(j).data).split(":")[0].equalsIgnoreCase(dataNum)) {
                    dataPayloadList << payload.get(j)
                    // also increment index
                    index = j
                }
            }
            String dataVarName = payloadItem.dataVarName ?: "data${dataNum}"
            dataVariablesStringBuilder.append("        Short ${dataVarName} = (short) (")
            dataPayloadList.eachWithIndex { dataPayloadListItem, dataPayloadListIndex ->
                String bits = ((String) dataPayloadListItem.data).split(":")[1]
                if (bits.contains("~")) {
                    int startBit = Integer.parseInt(bits.split("~")[0])
                    int stopBit = Integer.parseInt(bits.split("~")[1])
                    if (dataPayloadListIndex > 0) {
                        dataVariablesStringBuilder.append(" | \n                ")
                    }
                    if (startBit > 0) {
                        // shift value
                        dataVariablesStringBuilder.append("((${dataPayloadListItem.name} & ${getBitwiseAndByte(stopBit - startBit + 1)}) << ${startBit})")
                    } else {
                        dataVariablesStringBuilder.append("(${dataPayloadListItem.name} & ${getBitwiseAndByte(stopBit - startBit + 1)})")
                    }
                } else {
                    // we have a single bit field
                    int bit = Integer.parseInt(bits)

                    if (dataPayloadListIndex > 0) {
                        dataVariablesStringBuilder.append(" | \n                ")
                    }
                    if (dataPayloadListItem.type == "Boolean") {
                        if (bit > 0) {
                            dataVariablesStringBuilder.append("(${dataPayloadListItem.name} == true ? (1 << ${bit}) : 0)")
                        } else {
                            dataVariablesStringBuilder.append("(${dataPayloadListItem.name} == true ? 1 : 0)")
                        }
                    }
                }
            }
            dataVariablesStringBuilder.append(");\n")
        }
    }
    dataVariablesStringBuilder.append("\n")
    return dataVariablesStringBuilder.toString()
}

int getBitwiseAndByte(int totalBits) {
    // 1 = 0x1
    // 2 = 0x3
    // 3 = 0x7
    // 4 = 0xF
    return ((totalBits > 0 ? 1 : 0) |
            (totalBits > 1 ? 0x3 : 0) |
            (totalBits > 2 ? 0x7 : 0) |
            (totalBits > 3 ? 0xF : 0) |
            (totalBits > 4 ? 0xF : 0))
}

int getBitwiseAndByte(int totalBits, int startBit) {
    // 1 = 0x1
    // 2 = 0x3
    // 3 = 0x7
    // 4 = 0xF
    return ((totalBits > 0 ? 1 : 0) |
            (totalBits > 1 ? 0x3 : 0) |
            (totalBits > 2 ? 0x7 : 0) |
            (totalBits > 3 ? 0xF : 0) |
            (totalBits > 4 ? 0xF : 0)) << startBit
}

String createInstanceVariable(String variableName, String variableType, Object defaultValue) {
    if ("RESERVED".equals(variableName)) return "";

    if (defaultValue != null) {
        return "    private ${variableType} ${variableName} = ${defaultValue};\n"
    } else {
        return "    private ${variableType} ${variableName};\n"
    }
}

String createInstanceVariableGetterAndSetter(String variableName, String variableType) {
    if ("RESERVED".equals(variableName)) return "";

    return """    public ${variableType} get${variableName.capitalize()}() {
        return ${variableName};
    }

    public void set${variableName.capitalize()}(${variableType} ${variableName}) {
        this.${variableName} = ${variableName};
    }

"""
}

String createToString(String commandClass, String command, List payload) {
    StringBuilder stringBuilder = new StringBuilder("    @Override\n")
    stringBuilder.append("    public String toString() {\n")
    if (payload?.size() == 0) {
        stringBuilder.append("        return \"${command}()\";\n")
    } else {
        stringBuilder.append("        return \"${command}(\" +\n")
        payload.eachWithIndex { payloadItem, index ->
            if (payloadItem.name != "RESERVED") {
                stringBuilder.append("                \"")
                if(index > 0) {
                    stringBuilder.append(", ")
                }
                stringBuilder.append("${payloadItem.name}: \" + ${payloadItem.name} +\n")
            }
        }
        stringBuilder.append("                ')';\n")
    }
    stringBuilder.append("    }\n")
}

void generateCommandJavaClass(String basePackage, String baseCodeDirectory, String licenseText) {
    new File("${baseCodeDirectory}/").mkdirs()
    File commandJavaClass = new File("${baseCodeDirectory}/Command.java")
    if (commandJavaClass.exists()) commandJavaClass.delete()

    commandJavaClass << licenseText
    commandJavaClass << "package ${basePackage};\n"
    commandJavaClass << "\n"
    commandJavaClass << "import com.parrotha.internal.utils.HexUtils;\n"
    commandJavaClass << "\n"
    commandJavaClass << "import java.util.List;\n"
    commandJavaClass << "\n"
    commandJavaClass << "/**\n"
    commandJavaClass << " * Note: This code is autogenerated, changes will be overwritten.\n"
    commandJavaClass << " */\n"
    commandJavaClass << "public abstract class Command {\n"
    commandJavaClass << "    public abstract String getCMD();\n"
    commandJavaClass << "\n"
    commandJavaClass << "    public abstract List<Short> getPayload();\n"
    commandJavaClass << "\n"
    commandJavaClass << "    public abstract void setPayload(List<Short> payload);\n"
    commandJavaClass << "\n"
    commandJavaClass << "    public String format() {\n"
    commandJavaClass << "        return getCMD() + HexUtils.shortListToHexString(getPayload());\n"
    commandJavaClass << "    }\n"
    commandJavaClass << "\n"
    commandJavaClass << "    public Short getCommandClassIdentifier() {\n"
    commandJavaClass << "        return (short) HexUtils.hexStringToInt(getCMD().substring(0,2));\n"
    commandJavaClass << "    }\n"
    commandJavaClass << "\n"
    commandJavaClass << "    public Short getCommandIdentifier() {\n"
    commandJavaClass << "        return (short) HexUtils.hexStringToInt(getCMD().substring(2,4));\n"
    commandJavaClass << "    }\n"
    commandJavaClass << "}\n"
}

void generateZwaveJavaClass(List zwaveClasses, String basePackage, String baseCodeDirectory, String licenseText) {
    Map<String, Map<String, Object>> commandClasses = new LinkedHashMap<>()
    // SwitchMultilevelReport("2603", 0x26, "switchmultilevel", "SwitchMultilevelReport", 3);
    zwaveClasses.each { zci ->
        zci.commands.each { zcicmd ->
            String key = zci.commandClass + zcicmd.key
            if (commandClasses.containsKey(key)) {
                if (zci.version > commandClasses.get(key).version) {
                    commandClasses.get(key).version = zci.version
                }
            } else {
                commandClasses.put(key, [version: zci.version])
            }
            if (zcicmd.value.value != null && commandClasses.get(key).commandHex == null) {
                commandClasses.get(key).commandHex = String.format("%02X", zcicmd.value.value)
            }
            if (zci.value != null && commandClasses.get(key).commandClassHex == null) {
                commandClasses.get(key).commandClassHex = String.format("%02X", zci.value)
            }
            if (zci.commandClass != null && commandClasses.get(key).package == null) {
                commandClasses.get(key).package = zci.commandClass.toLowerCase()
            }
        }
    }

    new File("${baseCodeDirectory}/").mkdirs()
    File zwaveJavaClass = new File("${baseCodeDirectory}/Zwave.java")
    if (zwaveJavaClass.exists()) zwaveJavaClass.delete()

    zwaveJavaClass << licenseText
    zwaveJavaClass << "package ${basePackage};\n"
    zwaveJavaClass << "\n"
    zwaveJavaClass << "import groovy.lang.GroovyObjectSupport;\n"
    zwaveJavaClass << "import org.apache.commons.lang3.StringUtils;\n"
    zwaveJavaClass << "import com.parrotha.internal.utils.HexUtils;\n"
    zwaveJavaClass << "import org.slf4j.Logger;\n"
    zwaveJavaClass << "import org.slf4j.LoggerFactory;\n"
    zwaveJavaClass << "\n"
    zwaveJavaClass << "import java.lang.reflect.InvocationTargetException;\n"
    zwaveJavaClass << "import java.util.Arrays;\n"
    zwaveJavaClass << "import java.util.List;\n"
    zwaveJavaClass << "import java.util.Map;\n"
    zwaveJavaClass << "import java.util.stream.Collectors;\n"
    zwaveJavaClass << "\n"
    zwaveJavaClass << "/**\n"
    zwaveJavaClass << " * Note: This code is autogenerated, changes will be overwritten.\n"
    zwaveJavaClass << " */\n"
    zwaveJavaClass << "public class Zwave extends GroovyObjectSupport {\n"
    zwaveJavaClass << "    private static final Logger logger = LoggerFactory.getLogger(${basePackage}.Zwave.class);\n"
    zwaveJavaClass << "\n"
    zwaveJavaClass << "    public Command parse(String description, Map commandVersions) {\n"
    zwaveJavaClass << "        String[] descriptionArray = description.split(\",\");\n"
    zwaveJavaClass << "        if (descriptionArray.length == 3) {\n"
    zwaveJavaClass << "            String payloadString = descriptionArray[2].substring(\"payload: \".length()).trim();\n"
    zwaveJavaClass << "            if (descriptionArray[1].trim().startsWith(\"command:\")) {\n"
    zwaveJavaClass << "                String command = descriptionArray[1].trim().substring(\"command: \".length()).trim();\n"
    zwaveJavaClass << "                ZWaveCommandEnum zWaveCommand = ZWaveCommandEnum.getZWaveClass(command);\n"
    zwaveJavaClass << "                if (zWaveCommand != null) {\n"
    zwaveJavaClass << "                    try {\n"
    zwaveJavaClass << "                        int version = zWaveCommand.getMaxVersion();\n"
    zwaveJavaClass << "                        if (commandVersions.containsKey(zWaveCommand.getCommandClass()))\n"
    zwaveJavaClass << "                            version = (int) commandVersions.get(zWaveCommand.getCommandClass());\n"
    zwaveJavaClass << "                        Class<? extends Command> commandClazz = Class.forName(\"${basePackage}.commands.\" + zWaveCommand.getPackageName() + \"v\" + version + \".\" + zWaveCommand.getClassName()).asSubclass(Command.class);\n"
    zwaveJavaClass << "                        Command cmd = commandClazz.getDeclaredConstructor().newInstance();\n"
    zwaveJavaClass << "                        if (StringUtils.isNotBlank(payloadString)) {\n"
    zwaveJavaClass << "                            cmd.setPayload(hexStringToShortList(payloadString));\n"
    zwaveJavaClass << "                        }\n"
    zwaveJavaClass << "                        return cmd;\n"
    zwaveJavaClass << "                    } catch (ClassNotFoundException classNotFoundException) {\n"
    zwaveJavaClass << "                        classNotFoundException.printStackTrace();\n"
    zwaveJavaClass << "                    } catch (InstantiationException instantiationException) {\n"
    zwaveJavaClass << "                        instantiationException.printStackTrace();\n"
    zwaveJavaClass << "                    } catch (InvocationTargetException e) {\n"
    zwaveJavaClass << "                        e.printStackTrace();\n"
    zwaveJavaClass << "                    } catch (NoSuchMethodException e) {\n"
    zwaveJavaClass << "                        e.printStackTrace();\n"
    zwaveJavaClass << "                    } catch (IllegalAccessException illegalAccessException) {\n"
    zwaveJavaClass << "                        illegalAccessException.printStackTrace();\n"
    zwaveJavaClass << "                    }\n"
    zwaveJavaClass << "                }\n"
    zwaveJavaClass << "            }\n"
    zwaveJavaClass << "        }\n"
    zwaveJavaClass << "        return null;\n"
    zwaveJavaClass << "    }\n"
    zwaveJavaClass << "\n"
    zwaveJavaClass << "    private static List<Short> hexStringToShortList(String hexString) {\n"
    zwaveJavaClass << "        List<Short> shortList = Arrays.stream(HexUtils.hexStringToIntArray(hexString)).mapToObj(s -> Short.valueOf((short) s)).collect(Collectors.toList());\n"
    zwaveJavaClass << "        return shortList;\n"
    zwaveJavaClass << "    }\n"
    zwaveJavaClass << "\n"
    zwaveJavaClass << "    @Override\n"
    zwaveJavaClass << "    public Object getProperty(String propertyName) {\n"
    zwaveJavaClass << "        try {\n"
    zwaveJavaClass << "            Class<?> clazz = Class.forName(\"${basePackage}.commandclasses.\" + StringUtils.capitalize(propertyName));\n"
    zwaveJavaClass << "            return clazz.getDeclaredConstructor().newInstance();\n"
    zwaveJavaClass << "        } catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException e) {\n"
    zwaveJavaClass << "            logger.warn(\"Exception while loading Z-Wave class, may not be implemented.\", e);\n"
    zwaveJavaClass << "        }\n"
    zwaveJavaClass << "\n"
    zwaveJavaClass << "        return null;\n"
    zwaveJavaClass << "    }\n"
    zwaveJavaClass << "}\n"
}


void generateZWaveCommandEnumJavaClass(List zwaveClasses, String basePackage, String baseCodeDirectory, String licenseText) {
    Map<String, Map<String, Object>> commandClasses = new LinkedHashMap<>()
    // SwitchMultilevelReport("2603", 0x26, "switchmultilevel", "SwitchMultilevelReport", 3);
    zwaveClasses.each { zci ->
        zci.commands.each { zcicmd ->
            String key = zcicmd.key
            if (commandClasses.containsKey(key)) {
                if (zci.version > commandClasses.get(key).version) {
                    commandClasses.get(key).version = zci.version
                }
            } else {
                commandClasses.put(key, [version: zci.version])
            }
            if (zcicmd.value.value != null && commandClasses.get(key).commandHex == null) {
                commandClasses.get(key).commandHex = String.format("%02X", zcicmd.value.value)
            }
            if (zci.value != null && commandClasses.get(key).commandClassHex == null) {
                commandClasses.get(key).commandClassHex = String.format("%02X", zci.value)
            }
            if (zci.commandClass != null && commandClasses.get(key).package == null) {
                commandClasses.get(key).package = zci.commandClass.toLowerCase()
            }
        }
    }

    new File("${baseCodeDirectory}/").mkdirs()
    File zwaveCEJavaClass = new File("${baseCodeDirectory}/ZWaveCommandEnum.java")
    if (zwaveCEJavaClass.exists()) zwaveCEJavaClass.delete()

    zwaveCEJavaClass << licenseText
    zwaveCEJavaClass << "package ${basePackage};\n"
    zwaveCEJavaClass << "\n"
    zwaveCEJavaClass << "import org.apache.commons.lang3.StringUtils;\n"
    zwaveCEJavaClass << "import com.parrotha.internal.utils.HexUtils;\n"
    zwaveCEJavaClass << "import org.slf4j.Logger;\n"
    zwaveCEJavaClass << "import org.slf4j.LoggerFactory;\n"
    zwaveCEJavaClass << "\n"
    zwaveCEJavaClass << "import java.util.Arrays;\n"
    zwaveCEJavaClass << "import java.util.HashMap;\n"
    zwaveCEJavaClass << "import java.util.List;\n"
    zwaveCEJavaClass << "import java.util.Map;\n"
    zwaveCEJavaClass << "import java.util.stream.Collectors;\n"
    zwaveCEJavaClass << "\n"
    zwaveCEJavaClass << "/**\n"
    zwaveCEJavaClass << " * Note: This code is autogenerated, changes will be overwritten.\n"
    zwaveCEJavaClass << " */\n"
    zwaveCEJavaClass << "public enum ZWaveCommandEnum {\n"

    commandClasses.sort { it.value.commandClassHex + it.value.commandHex }.keySet().eachWithIndex { String key, index ->
        Map commandClass = commandClasses.get(key)
        zwaveCEJavaClass << "    ${key}(\"${commandClass.commandClassHex}${commandClass.commandHex}\", 0x${commandClass.commandClassHex}, 0x${commandClass.commandHex}, \"${commandClass.package}\", \"${key}\", ${commandClass.version})"
        if (index < commandClasses.size() - 1) {
            zwaveCEJavaClass << ",\n"
        } else {
            zwaveCEJavaClass << ";\n"
        }
    }

    zwaveCEJavaClass << "\n"
    zwaveCEJavaClass << "    private static Map<String, ZWaveCommandEnum> codeToCommandClassMapping;\n"
    zwaveCEJavaClass << "\n"
    zwaveCEJavaClass << "    private String key;\n"
    zwaveCEJavaClass << "    private int commandClass;\n"
    zwaveCEJavaClass << "    private int command;\n"
    zwaveCEJavaClass << "    private String packageName;\n"
    zwaveCEJavaClass << "    private String className;\n"
    zwaveCEJavaClass << "    private int maxVersion;\n"
    zwaveCEJavaClass << "\n"
    zwaveCEJavaClass << "    ZWaveCommandEnum(String key, int commandClass, int command, String packageName, String className, int maxVersion) {\n"
    zwaveCEJavaClass << "        this.key = key;\n"
    zwaveCEJavaClass << "        this.commandClass = commandClass;\n"
    zwaveCEJavaClass << "        this.command = command;\n"
    zwaveCEJavaClass << "        this.packageName = packageName;\n"
    zwaveCEJavaClass << "        this.className = className;\n"
    zwaveCEJavaClass << "        this.maxVersion = maxVersion;\n"
    zwaveCEJavaClass << "    }\n"
    zwaveCEJavaClass << "\n"
    zwaveCEJavaClass << "    private static void initMapping() {\n"
    zwaveCEJavaClass << "        codeToCommandClassMapping = new HashMap<String, ZWaveCommandEnum>();\n"
    zwaveCEJavaClass << "        for (ZWaveCommandEnum s : values()) {\n"
    zwaveCEJavaClass << "            codeToCommandClassMapping.put(s.key, s);\n"
    zwaveCEJavaClass << "        }\n"
    zwaveCEJavaClass << "    }\n"
    zwaveCEJavaClass << "\n"
    zwaveCEJavaClass << "    public static ZWaveCommandEnum getZWaveClass(String s) {\n"
    zwaveCEJavaClass << "        if (codeToCommandClassMapping == null) {\n"
    zwaveCEJavaClass << "            initMapping();\n"
    zwaveCEJavaClass << "        }\n"
    zwaveCEJavaClass << "        return codeToCommandClassMapping.get(s);\n"
    zwaveCEJavaClass << "    }\n"
    zwaveCEJavaClass << "\n"
    zwaveCEJavaClass << "    public String getKey() {\n"
    zwaveCEJavaClass << "        return key;\n"
    zwaveCEJavaClass << "    }\n"
    zwaveCEJavaClass << "\n"
    zwaveCEJavaClass << "    public int getCommandClass() {\n"
    zwaveCEJavaClass << "        return commandClass;\n"
    zwaveCEJavaClass << "    }\n"
    zwaveCEJavaClass << "\n"
    zwaveCEJavaClass << "    public int getCommand() {\n"
    zwaveCEJavaClass << "        return command;\n"
    zwaveCEJavaClass << "    }\n"
    zwaveCEJavaClass << "\n"
    zwaveCEJavaClass << "    public String getPackageName() {\n"
    zwaveCEJavaClass << "        return packageName;\n"
    zwaveCEJavaClass << "    }\n"
    zwaveCEJavaClass << "\n"
    zwaveCEJavaClass << "    public String getClassName() {\n"
    zwaveCEJavaClass << "        return className;\n"
    zwaveCEJavaClass << "    }\n"
    zwaveCEJavaClass << "\n"
    zwaveCEJavaClass << "    public int getMaxVersion() {\n"
    zwaveCEJavaClass << "        return maxVersion;\n"
    zwaveCEJavaClass << "    }\n"
    zwaveCEJavaClass << "}\n"
}